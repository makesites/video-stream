<polymer-element name="video-stream" extends="video" attributes="audio filter">
<script>
	Polymer('video-stream', {
		created: function() {
			// this is executed when the tag is inserted
			var video = this;

			// get video dimensions
			this.getSize();

			// organize available streams
			this._sources();

			// load the first stream
			video.src = this.loadStream();

			// events
			window.addEventListener('resize', this._resize, false);

		},
		// public methods
		// - returns video dimensions
		getSize: function(){
			// get video dimensions
			var video = {
				width: this.offsetWidth || this.clientWidth || 0,
				height: this.offsetHeight || this.clientHeight || 0,
			}
			// initially video size is set to the max dimensions
			var max = video;
			var active = video;
			// check memory
			var memory = this._memory();
			// * convention - if reaching memory limits cut (max) resolution to half
			if( memory > 90 ){
				active.width = active.width/2;
				active.height = active.height/2;
			}
			// save sizes for later
			this._size = {
				max: max,
				active: active
			}

			return active;
		},

		// - picks a source
		loadStream: function( quality ){
			// fallbacks
			quality = quality || false;
			// variables
			var sources = this.sources;
			// if quality selected pick a subset
			//...
			var stream = this._pickStream( sources );
			// save selected steam
			this.selectedStream = stream;
			// check if selected stream is cached
			//...
			// check against the max resolution that can play...

			// if not cached play a lower res until buffered
			this.activeStream = this.selectedStream;

			// return source location
			return this.activeStream.src;
		},
		switchStream: function( quality ){
		},
		// internal methods
		// - organizes sources
		_sources: function(){
			var sources = [];
			var dom = this.getElementsByTagName('source');
			// save dimensions
			for (var i in dom) {
				var tag = dom[i];
				// better way to check for an element?
				if( !tag.attributes ) continue;
				// first check type (only include files that can be used)
				var supported = this._checkType( tag.attributes['type'].value );
				if( !supported ) continue;
				// support other methods (other than attributes) for setting resolution?
				var source = {
					width: parseInt( tag.attributes['width'].value ) || 0,
					height: parseInt( tag.attributes['height'].value ) || 0,
					src: tag.attributes['src'].value || ""
				};
				sources.push( source );
			}

			this.sources = sources;
			//console.log("sources:", this.sources);
		},

		_progress: function( e ){
			// look up cache
			console.log("progress", e);
		},

		_speed: function( e ){
			console.log("speed:", e);
		},

		_memory: function(){
			return (console.memory) ? Math.round( 100 * (console.memory.usedJSHeapSize / console.memory.totalJSHeapSize)) : 0;
		},

		_resize: function( e ){
			console.log( "resize:", this );
		},

		_checkType: function( type ){
			// empty string means no support - other options: maybe, probably
			return ( this.canPlayType( type ) !== "" );
		},

		_pickStream: function( sources ){
			// fallbacks
			sources = sources || this.sources || [];
			// variables
			var selected = {};
			// get size based on params
			var size = this.getSize();
			// loop through streams
			//console.log("size", size);
			for( var i in sources ){
				// only change the selected source if it is a different size
				if( selected.width == sources[i].width && selected.height == sources[i].height ) continue;
				// compare against the "allowed" size
				if( sources[i].width <= size.width && sources[i].height <= size.height ){
					selected = sources[i];
				}
			}
			return selected;
		}

	});

	// this is executed on import
	// underscore helpers
	var _ = window._ || {

		// helpers
		// Based on Underscode.js bind: http://underscorejs.org/#bind
		_bind: function(func, context) {
			var args, bound;
			if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
			if (!_.isFunction(func)) throw new TypeError;
			args = slice.call(arguments, 2);
			return bound = function() {
				if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
				ctor.prototype = func.prototype;
				var self = new ctor;
				ctor.prototype = null;
				var result = func.apply(self, args.concat(slice.call(arguments)));
				if (Object(result) === result) return result;
				return self;
			};
		},
		// Based on Underscore.js debounce: http://underscorejs.org/#debounce
		debounce: function(func, wait, immediate) {
			var timeout, args, context, timestamp, result;

			var later = function() {
				var last = _.now() - timestamp;
				if (last < wait) {
					timeout = setTimeout(later, wait - last);
				} else {
					timeout = null;
					if (!immediate) {
						result = func.apply(context, args);
						context = args = null;
					}
				}
			};

			return function() {
				context = this;
				args = arguments;
				timestamp = _.now();
				var callNow = immediate && !timeout;
				if (!timeout) {
					timeout = setTimeout(later, wait);
				}
				if (callNow) {
					result = func.apply(context, args);
					context = args = null;
				}

				return result;
			};
		},
		now: Date.now || function() { return new Date().getTime(); },

		isFunction: function(obj) {
			return typeof obj === 'function';
		}

	};

</script>
<style>
	/* element styles */
	video-stream {

	}
</style>
</polymer-element>