<polymer-element name="video-stream" extends="video" attributes="audio filter">
<script>
	Polymer('video-stream', {
		created: function() {
			// this is executed when the tag is inserted
			var video = this;

			// get video dimensions
			this.getSize();

			// organize available streams
			this._sources();

			// load the first stream
			video.src = this.loadStream();

		},
		// public methods
		// - returns video dimensions
		getSize: function(){
			// get video dimensions
			var video = {
				width: this.offsetWidth || this.clientWidth || 0,
				height: this.offsetHeight || this.clientHeight || 0,
			}
			// initially video size is set to the max dimensions
			var max = video;
			var active = video;
			// check memory
			var memory = this._memory();
			// * convention - if reaching memory limits cut (max) resolution to half
			if( memory > 90 ){
				active.width = active.width/2;
				active.height = active.height/2;
			}
			// save sizes for later
			this._size = {
				max: max,
				active: active
			}

			return active;
		},

		// - picks a source
		loadStream: function( quality ){
			// fallbacks
			quality = quality || false;
			// variables
			var sources = this.sources;
			// if quality selected pick a subset
			//...
			var stream = this._pickStream( sources );
			// save selected steam
			this.selectedStream = stream;
			// check if selected stream is cached
			//...
			// check against the max resolution that can play...

			// if not cached play a lower res until buffered
			this.activeStream = this.selectedStream;

			// return source location
			return this.activeStream.src;
		},
		switchStream: function( quality ){
		},
		// internal methods
		// - organizes sources
		_sources: function(){
			var sources = [];
			var dom = this.getElementsByTagName('source');
			// save dimensions
			for (var i in dom) {
				var tag = dom[i];
				// better way to check for an element?
				if( !tag.attributes ) continue;
				// first check type (only include files that can be used)
				var supported = this._checkType( tag.attributes['type'].value );
				if( !supported ) continue;
				// support other methods (other than attributes) for setting resolution?
				var source = {
					width: parseInt( tag.attributes['width'].value ) || 0,
					height: parseInt( tag.attributes['height'].value ) || 0,
					src: tag.attributes['src'].value || ""
				};
				sources.push( source );
			}

			this.sources = sources;
			//console.log("sources:", this.sources);
		},

		_progress: function( e ){
			// look up cache
			console.log("progress", e);
		},

		_speed: function( e ){
			console.log("speed:", e);
		},

		_memory: function(){
			return (console.memory) ? Math.round( 100 * (console.memory.usedJSHeapSize / console.memory.totalJSHeapSize)) : 0;
		},

		_checkType: function( type ){
			// empty string means no support - other options: maybe, probably
			return ( this.canPlayType( type ) !== "" );
		},

		_pickStream: function( sources ){
			// fallbacks
			sources = sources || this.sources || [];
			// variables
			var selected = {};
			// get size based on params
			var size = this.getSize();
			// loop through streams
			//console.log("size", size);
			for( var i in sources ){
				// compare against the "allowed" size
				if( sources[i].width <= size.width && sources[i].height <= size.height ){
					selected = sources[i];
				}
			}
			return selected;
		}

	});

	// this is executed on import

</script>
<style>
	/* element styles */
	video-stream {

	}
</style>
</polymer-element>